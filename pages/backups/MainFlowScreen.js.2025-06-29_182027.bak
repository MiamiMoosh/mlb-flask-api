import LottieBurst from './LottieBurst';
import * as Haptics from 'expo-haptics';

import { useKeepAwake } from 'expo-keep-awake'; // optional, prevents screen sleep

import React, { useState, useEffect, useRef } from 'react';

import {
  View,
  Text,
  StyleSheet,
  Button,
  TextInput,
  FlatList,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Share
} from 'react-native';
import { Audio } from 'expo-av';
import ShimmerPlaceHolder from 'react-native-shimmer-placeholder';
import AnimatedCard from './AnimatedCard';
import { useGlobalStore } from '../store/globalStore';
import { animationPresets } from '../utils/animationPresets';


export default function MainFlowScreen({ navigation }) {
	
	const triggerBurst = (rarity) => {
	const burstVariants = {
	common: ['common', 'confetti1', 'spark'],
	rare: ['rare', 'confetti2', 'energy'],
	epic: ['epic', 'moon'],
	legendary: ['legendary', 'confetti']
	};

	const bursts = {
	epic: require('../assets/effects/epic.json'),
	legendary: require('../assets/effects/legendary.json'),
	rare: require('../assets/effects/rare.json'),
	common: require('../assets/effects/common.json'),
	confetti: require('../assets/effects/confetti.json'),
	confetti1: require('../assets/effects/confetti2.json'),
	energy: require('../assets/effects/energy.json'),
	moon: require('../assets/effects/moon.json'),
	spark: require('../assets/effects/spark.json')
	};

	const pool = burstVariants[rarity] || ['common'];
	const chosen = pool[Math.floor(Math.random() * pool.length)];

	if (bursts[chosen]) {
	setBurstSource(bursts[chosen]);
	setShowBurst(true);
	setTimeout(() => setShowBurst(false), 1500);
	}
	};

	const getRarityFromName = (name) => {
	const lowered = name.toLowerCase();
	if (/legendary|dragon|phoenix|mythic/.test(lowered)) return 'legendary';
	if (/epic|crystal|storm|void/.test(lowered)) return 'epic';
	if (/rare|silver|arcane|ember/.test(lowered)) return 'rare';
	return 'common';
	};
	const {
	inventory,
	finalMessage,
	cardImage,
	containerImage,
	hydrate,
	setInventory
	} = useGlobalStore();

	const [burstSource, setBurstSource] = useState(null);
	const [showBurst, setShowBurst] = useState(false);

	const [lockedIndexes, setLockedIndexes] = useState([]);
	const [numToPick, setNumToPick] = useState('');
	const [pickedItems, setPickedItems] = useState([]);
	const [revealIndex, setRevealIndex] = useState(0);
	const [showFinal, setShowFinal] = useState(false);
	const [introDone, setIntroDone] = useState(false);
	const [history, setHistory] = useState([]);
	const scrollRef = useRef(null);

	const revealSound = useRef(null);
	const finishSound = useRef(null);

	const luckyPickEnabled = true;
	const preventDuplicates = true;
	const forceEpicOrLegendary = true;

  useEffect(() => {
	if (!luckyPick && pickedItems.length && revealIndex < pickedItems.length - 1) {
		const timer = setTimeout(() => showNextItem(), presets.autoRevealDelay);
		return () => clearTimeout(timer);
	}
    hydrate();
    runIntroSequence();
    loadSounds();
    return () => {
      revealSound.current?.unloadAsync();
      finishSound.current?.unloadAsync();
    };
  }, []);

  const loadSounds = async () => {
    revealSound.current = new Audio.Sound();
    finishSound.current = new Audio.Sound();
    await revealSound.current.loadAsync(require('../assets/reveal.mp3'));
    await finishSound.current.loadAsync(require('../assets/final.mp3'));
  };

  const runIntroSequence = () => {
    setTimeout(() => {
      scrollRef.current?.scrollToEnd({ animated: true });
      setTimeout(() => setIntroDone(true), 1000);
    }, 1000);
  };

  const shuffleAndPick = () => {
  const expandedList = inventory.flatMap(item =>
    Array(item.quantity).fill(item.name)
  );

  let filtered = [...new Set(expandedList)];

  if (!preventDuplicates) {
    filtered = [...expandedList];
  } else if (filtered.length < parseInt(numToPick)) {
    alert("Not enough unique items to pick without duplicates.");
    return;
  }

  const shuffled = filtered.sort(() => 0.5 - Math.random());

  let picked = shuffled.slice(0, parseInt(numToPick));

  if (forceEpicOrLegendary) {
    const hasEpicOrLegendary = picked.some(item => {
      const r = getRarityFromName(item);
      return r === 'epic' || r === 'legendary';
    });

    if (!hasEpicOrLegendary) {
      const fallback = expandedList.find(i =>
        ['epic', 'legendary'].includes(getRarityFromName(i))
      );
      if (fallback) picked[0] = fallback;
    }
  }

  setPickedItems(picked);
  setRevealIndex(luckyPickEnabled ? picked.length - 1 : 0);
  setShowFinal(luckyPickEnabled);
  if (luckyPickEnabled) reduceInventoryQuantities(picked);
};

  const showNextItem = async () => {
  const item = pickedItems[revealIndex + 1];
  const rarity = getRarityFromName(item);

  const sfxMap = {
    common: require('../assets/sfx/common.mp3'),
    rare: require('../assets/sfx/rare.mp3'),
    epic: require('../assets/sfx/epic.mp3'),
    legendary: require('../assets/sfx/legendary.mp3')
  };

  if (sfxMap[rarity]) {
    await Audio.Sound.createAsync(sfxMap[rarity], { shouldPlay: true });
  }

  await Haptics.selectionAsync();
  triggerBurst(rarity);

  if (revealIndex < pickedItems.length - 1) {
    setRevealIndex(prev => prev + 1);
  } else {
    setShowFinal(true);
    reduceInventoryQuantities();
    await Audio.Sound.createAsync(require('../assets/sfx/moon.mp3'), { shouldPlay: true });
  }

  useGlobalStore.getState().logSession(pickedItems);
};

	const reduceInventoryQuantities = (used = pickedItems) => {
	  const updated = [...inventory];
	  used.forEach((itemName, i) => {
		if (lockedIndexes.includes(i)) return;

		const index = updated.findIndex(i => i.name === itemName);
		if (index !== -1 && updated[index].quantity > 0) {
		  updated[index].quantity -= 1;
		}
	  });
	  setInventory(updated);
	};

  const exportHistory = async () => {
	  const logs = useGlobalStore.getState().analytics.logs;
	  const lines = logs.map(log => {
		const date = new Date(log.timestamp).toLocaleString();
		const picks = log.picked.join(', ');
		const rc = JSON.stringify(log.rarityCounts);
		return `${date}\nPicks: ${picks}\nRarities: ${rc}\n\n`;
	  });

	  const fullText = lines.join('');

	  try {
		await Share.share({
		  title: 'Session History',
		  message: fullText
		});
	  } catch (err) {
		console.error('Error sharing:', err);
	  }
	};

  const replayLast = () => {
    setShowFinal(false);
    setRevealIndex(pickedItems.length - 1);
  };

  const resetOrder = () => {
    setPickedItems([]);
    setNumToPick('');
    setRevealIndex(0);
    setShowFinal(false);
  };

  const columns = presets.layout === '3x4' ? 3 : presets.layout === '5x6' ? 5 : 4;

return (
  <>
    <LottieBurst visible={showBurst} source={burstSource} />
    <KeyboardAvoidingView style={[styles.container, presets.darkMode && styles.darkContainer]}>
      <Text style={styles.title}>Order Picker</Text>

      {!introDone ? (
        <ScrollView ref={scrollRef} style={{ height: 100 }}>
          {inventory.map((item, i) => (
            <Text key={i} style={styles.scrollItem}>{item.name}</Text>
          ))}
        </ScrollView>
      ) : containerImage && (
        <Image source={{ uri: containerImage }} style={styles.containerPreview} />
      )}

      {!pickedItems.length ? (
        <>
          <Text style={styles.label}>Enter number of items to pick:</Text>
          <TextInput
            style={styles.input}
            keyboardType="numeric"
            value={numToPick}
            onChangeText={setNumToPick}
            placeholder="e.g. 20"
          />
          <Button title="Start Picking" onPress={shuffleAndPick} />
        </>
      ) : (
        <>
          <FlatList
            data={pickedItems.slice(0, revealIndex + 1)}
            keyExtractor={(item, index) => index.toString()}
            numColumns={columns}
            renderItem={({ item, index }) => {
              const rarity = getRarityFromName(item);
              const locked = lockedIndexes.includes(index);
              const toggleLock = () => {
                setLockedIndexes((prev) =>
                  prev.includes(index) ? prev.filter(i => i !== index) : [...prev, index]
                );
              };

              return (
                <TouchableOpacity onLongPress={() => toggleLock(index)}>
                  <AnimatedCard
                    name={item}
                    rarity={rarity}
                    imageSource={cardImage}
                    locked={locked}
                  />
                </TouchableOpacity>
              );
            }}
            contentContainerStyle={styles.grid}
          />
          {!showFinal ? (
            <Button title="Show Next Item" onPress={showNextItem} />
          ) : (
            <>
              <Text style={styles.finalMessage}>{finalMessage}</Text>
              <Button title="Replay Last Item" onPress={replayLast} />
              <Button title="Start New Order" onPress={resetOrder} />
              <Button title="Export History" onPress={exportHistory} />
            </>
          )}
        </>
      )}

      <View style={{ marginVertical: 20 }}>
        <Text style={{ fontSize: 16, fontWeight: 'bold' }}>ðŸ“ˆ Stats</Text>
        <Text>Sessions: {analytics.sessionCount}</Text>
        <Text>Common: {analytics.allTimeRarity.common}</Text>
        <Text>Rare: {analytics.allTimeRarity.rare}</Text>
        <Text>Epic: {analytics.allTimeRarity.epic}</Text>
        <Text>Legendary: {analytics.allTimeRarity.legendary}</Text>
      </View>

      <View style={styles.bottomButtons}>
        <Button title="Edit Inventory" onPress={() => navigation.navigate('Inventory')} />
        <Button title="Settings" onPress={() => navigation.navigate('Settings')} />
      </View>
    </KeyboardAvoidingView>
  </>
);
}

const styles = StyleSheet.create({
  container: { padding: 20, flex: 1, backgroundColor: '#fff' },
  title: { fontSize: 28, fontWeight: 'bold', marginBottom: 10 },
  label: { fontSize: 16 },
  input: {
    borderColor: '#ccc',
    borderWidth: 1,
    padding: 8,
    marginVertical: 10,
    borderRadius: 6
  },
  grid: { alignItems: 'center', marginTop: 20 },
  finalMessage: {
    fontSize: 20,
    fontWeight: '600',
    marginVertical: 20,
    textAlign: 'center'
  },
  containerPreview: {
    width: 100,
    height: 100,
    marginBottom: 20,
    borderRadius: 8,
    alignSelf: 'center'
  },
  shimmer: {
    width: 100,
    height: 110,
    borderRadius: 10,
    margin: 5
  },
  scrollItem: {
    fontSize: 18,
    paddingVertical: 2
  },
  bottomButtons: {
    marginTop: 30,
    flexDirection: 'row',
    justifyContent: 'space-between'
  },
  darkContainer: {
  backgroundColor: '#111',
}
});