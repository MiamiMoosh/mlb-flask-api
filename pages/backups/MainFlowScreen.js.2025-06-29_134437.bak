import LottieBurst from './LottieBurst';
import * as Haptics from 'expo-haptics';

import { useGlobalStore } from '../store/globalStore';
import { useKeepAwake } from 'expo-keep-awake'; // optional, prevents screen sleep

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Button,
  TextInput,
  FlatList,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Share
} from 'react-native';
import { Audio } from 'expo-av';
import ShimmerPlaceHolder from 'react-native-shimmer-placeholder';
import AnimatedCard from './AnimatedCard';
import { useGlobalStore } from '../store/globalStore';
import { animationPresets } from '../utils/animationPresets';

const [burstSource, setBurstSource] = useState(null);
const [showBurst, setShowBurst] = useState(false);

const [lockedIndexes, setLockedIndexes] = useState([]);

const triggerBurst = (rarity) => {
  const bursts = {
    epic: require('../assets/effects/epic.json'),
    legendary: require('../assets/effects/legendary.json'),
  };
  if (bursts[rarity]) {
    setBurstSource(bursts[rarity]);
    setShowBurst(true);
    setTimeout(() => setShowBurst(false), 1500);
  }
};

const getRarityFromName = (name) => {
  const lowered = name.toLowerCase();
  if (lowered.match(/legendary|dragon|phoenix/)) return 'legendary';
  if (lowered.match(/epic|crystal|storm/)) return 'epic';
  if (lowered.match(/rare|silver|arcane/)) return 'rare';
  return 'common';
};

export default function MainFlowScreen({ navigation }) {
  const {
    inventory,
    finalMessage,
    cardImage,
    containerImage,
    hydrate,
    setInventory
  } = useGlobalStore();

  const [numToPick, setNumToPick] = useState('');
  const [pickedItems, setPickedItems] = useState([]);
  const [revealIndex, setRevealIndex] = useState(0);
  const [showFinal, setShowFinal] = useState(false);
  const [introDone, setIntroDone] = useState(false);
  const [history, setHistory] = useState([]);
  const scrollRef = useRef(null);

  const revealSound = useRef(null);
  const finishSound = useRef(null);
  
  const luckyPickEnabled = true;
	const preventDuplicates = true;
	const forceEpicOrLegendary = true;

  useEffect(() => {
    hydrate();
    runIntroSequence();
    loadSounds();
    return () => {
      revealSound.current?.unloadAsync();
      finishSound.current?.unloadAsync();
    };
  }, []);

  const loadSounds = async () => {
    revealSound.current = new Audio.Sound();
    finishSound.current = new Audio.Sound();
    await revealSound.current.loadAsync(require('../assets/reveal.mp3'));
    await finishSound.current.loadAsync(require('../assets/final.mp3'));
  };

  const runIntroSequence = () => {
    setTimeout(() => {
      scrollRef.current?.scrollToEnd({ animated: true });
      setTimeout(() => setIntroDone(true), 1000);
    }, 1000);
  };

  const shuffleAndPick = () => {
  const expandedList = inventory.flatMap(item =>
    Array(item.quantity).fill(item.name)
  );

  let filtered = [...new Set(expandedList)];

  if (!preventDuplicates) {
    filtered = [...expandedList];
  } else if (filtered.length < parseInt(numToPick)) {
    alert("Not enough unique items to pick without duplicates.");
    return;
  }

  const shuffled = filtered.sort(() => 0.5 - Math.random());

  let picked = shuffled.slice(0, parseInt(numToPick));

  if (forceEpicOrLegendary) {
    const hasEpicOrLegendary = picked.some(item => {
      const r = getRarityFromName(item);
      return r === 'epic' || r === 'legendary';
    });

    if (!hasEpicOrLegendary) {
      const fallback = expandedList.find(i =>
        ['epic', 'legendary'].includes(getRarityFromName(i))
      );
      if (fallback) picked[0] = fallback;
    }
  }

  setPickedItems(picked);
  setRevealIndex(luckyPickEnabled ? picked.length - 1 : 0);
  setShowFinal(luckyPickEnabled);
  if (luckyPickEnabled) reduceInventoryQuantities(picked);
};

  const showNextItem = async () => {
	  const item = pickedItems[revealIndex + 1];
	  const rarity = getRarityFromName(item);

	  if (rarity === 'epic') {
		await Audio.Sound.createAsync(require('../assets/sfx/epic.mp3'), { shouldPlay: true });
	  } else if (rarity === 'legendary') {
		await Audio.Sound.createAsync(require('../assets/sfx/legendary.mp3'), { shouldPlay: true });
	  } else if (rarity === 'rare') {
		await Audio.Sound.createAsync(require('../assets/sfx/rare.mp3'), { shouldPlay: true });
	  }

	  await Haptics.selectionAsync();
	  triggerBurst(rarity);

	  if (revealIndex < pickedItems.length - 1) {
		setRevealIndex(prev => prev + 1);
	  } else {
		setShowFinal(true);
		reduceInventoryQuantities();
		await Audio.Sound.createAsync(require('../assets/sfx/ambient.mp3'), { shouldPlay: true });
	  }
	  useGlobalStore.getState().logSession(pickedItems);
	};

	const reduceInventoryQuantities = (used = pickedItems) => {
	  const updated = [...inventory];
	  used.forEach((itemName, i) => {
		if (lockedIndexes.includes(i)) return;

		const index = updated.findIndex(i => i.name === itemName);
		if (index !== -1 && updated[index].quantity > 0) {
		  updated[index].quantity -= 1;
		}
	  });
	  setInventory(updated);
	};

  const exportHistory = async () => {
	  const logs = useGlobalStore.getState().analytics.logs;
	  const lines = logs.map(log => {
		const date = new Date(log.timestamp).toLocaleString();
		const picks = log.picked.join(', ');
		const rc = JSON.stringify(log.rarityCounts);
		return `${date}\nPicks: ${picks}\nRarities: ${rc}\n\n`;
	  });

	  const fullText = lines.join('');

	  try {
		await Share.share({
		  title: 'Session History',
		  message: fullText
		});
	  } catch (err) {
		console.error('Error sharing:', err);
	  }
	};

  const replayLast = () => {
    setShowFinal(false);
    setRevealIndex(pickedItems.length - 1);
  };

  const resetOrder = () => {
    setPickedItems([]);
    setNumToPick('');
    setRevealIndex(0);
    setShowFinal(false);
  };

  return (
	<LottieBurst visible={showBurst} source={burstSource} />
    <KeyboardAvoidingView style={styles.container} behavior={Platform.OS === 'ios' ? 'padding' : undefined}>
      <Text style={styles.title}>Order Picker</Text>

      {!introDone ? (
        <ScrollView ref={scrollRef} style={{ height: 100 }}>
          {inventory.map((item, i) => (
            <Text key={i} style={styles.scrollItem}>{item.name}</Text>
          ))}
        </ScrollView>
      ) : containerImage && (
        <Image source={{ uri: containerImage }} style={styles.containerPreview} />
      )}

      {!pickedItems.length ? (
        <>
          <Text style={styles.label}>Enter number of items to pick:</Text>
          <TextInput
            style={styles.input}
            keyboardType="numeric"
            value={numToPick}
            onChangeText={setNumToPick}
            placeholder="e.g. 20"
          />
          <Button title="Start Picking" onPress={shuffleAndPick} />
        </>
      ) : (
        <>
          <FlatList
            data={pickedItems.slice(0, revealIndex + 1)}
            keyExtractor={(item, index) => index.toString()}
            numColumns={4}
            renderItem={({ item, index }) => {
			  const rarity = getRarityFromName(item);
			  const locked = lockedIndexes.includes(index);
			  const toggleLock = () => {
				setLockedIndexes((prev) =>
				  prev.includes(index) ? prev.filter(i => i !== index) : [...prev, index]
				);
			  };

			  return (
				<TouchableOpacity onLongPress={toggleLock}>
				  <AnimatedCard
					name={item}
					rarity={rarity}
					imageSource={cardImage}
					locked={locked}
				  />
				</TouchableOpacity>
			  );
			}}
            contentContainerStyle={styles.grid}
          />
          {!showFinal ? (
            <Button title="Show Next Item" onPress={showNextItem} />
          ) : (
            <>
              <Text style={styles.finalMessage}>{finalMessage}</Text>
              <Button title="Replay Last Item" onPress={replayLast} />
              <Button title="Start New Order" onPress={resetOrder} />
              <Button title="Export History" onPress={exportHistory} />
            </>
          )}
        </>
      )}
	<View style={{ marginVertical: 20 }}>
	  <Text style={{ fontSize: 16, fontWeight: 'bold' }}>ðŸ“ˆ Stats</Text>
	  <Text>Sessions: {analytics.sessionCount}</Text>
	  <Text>Common: {analytics.allTimeRarity.common}</Text>
	  <Text>Rare: {analytics.allTimeRarity.rare}</Text>
	  <Text>Epic: {analytics.allTimeRarity.epic}</Text>
	  <Text>Legendary: {analytics.allTimeRarity.legendary}</Text>
	</View>
      <View style={styles.bottomButtons}>
        <Button title="Edit Inventory" onPress={() => navigation.navigate('Inventory')} />
        <Button title="Settings" onPress={() => navigation.navigate('Settings')} />
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { padding: 20, flex: 1, backgroundColor: '#fff' },
  title: { fontSize: 28, fontWeight: 'bold', marginBottom: 10 },
  label: { fontSize: 16 },
  input: {
    borderColor: '#ccc',
    borderWidth: 1,
    padding: 8,
    marginVertical: 10,
    borderRadius: 6
  },
  grid: { alignItems: 'center', marginTop: 20 },
  finalMessage: {
    fontSize: 20,
    fontWeight: '600',
    marginVertical: 20,
    textAlign: 'center'
  },
  containerPreview: {
    width: 100,
    height: 100,
    marginBottom: 20,
    borderRadius: 8,
    alignSelf: 'center'
  },
  shimmer: {
    width: 100,
    height: 110,
    borderRadius: 10,
    margin: 5
  },
  scrollItem: {
    fontSize: 18,
    paddingVertical: 2
  },
  bottomButtons: {
    marginTop: 30,
    flexDirection: 'row',
    justifyContent: 'space-between'
  }
});